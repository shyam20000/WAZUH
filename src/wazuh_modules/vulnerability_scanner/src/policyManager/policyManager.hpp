/*
 * Wazuh vulnerability scanner - Policy Manager
 * Copyright (C) 2015, Wazuh Inc.
 * March 25, 2023.
 *
 * This program is free software; you can redistribute it
 * and/or modify it under the terms of the GNU General Public
 * License (version 2) as published by the FSF - Free Software
 * Foundation.
 */

#ifndef _POLICY_MANAGER_HPP
#define _POLICY_MANAGER_HPP

#include "observer.hpp"
#include "routerSubscriber.hpp"
#include "singleton.hpp"
#include <external/nlohmann/json.hpp>
#include <functional>
#include <memory>
#include <string>
#include <vector>

/**
 * @brief PolicyManager
 *
 */
class PolicyManager final : public Singleton<PolicyManager>
{
private:
    Subject<nlohmann::json&> m_subject;
    nlohmann::json m_configuration;
    std::unique_ptr<RouterSubscriber> m_policyChangeSubscription;
    void setDefaultPolicy()
    {
        // Set default policy
        if (!m_configuration.contains("updater"))
        {
            m_configuration["updater"] = nlohmann::json::object();
            m_configuration["updater"]["interval"] = 10 * 60;
            m_configuration["updater"]["ondemand"] = true;
            m_configuration["updater"]["topicName"] = "vulnerability_scanner_updater";
            m_configuration["updater"]["configData"] = nlohmann::json::object();
            m_configuration["updater"]["configData"]["contentSource"] = "api";
            m_configuration["updater"]["configData"]["compressionType"] = "raw";
            m_configuration["updater"]["configData"]["versionedContent"] = "false";
            m_configuration["updater"]["configData"]["deleteDownloadedContent"] = false;
            m_configuration["updater"]["configData"]["url"] = "https://swapi.dev/api/people/1";
            m_configuration["updater"]["configData"]["outputFolder"] = "";
            m_configuration["updater"]["configData"]["dataFormat"] = "json";
            m_configuration["updater"]["configData"]["fileName"] = "api_file.json";
            m_configuration["updater"]["configData"]["apiParameters"] = nlohmann::json::object();
            m_configuration["updater"]["configData"]["apiParameters"]["itemsPerRequest"] = nlohmann::json::object();
            m_configuration["updater"]["configData"]["apiParameters"]["itemsPerRequest"]["name"] = "limit";
            m_configuration["updater"]["configData"]["apiParameters"]["itemsPerRequest"]["value"] = 100;
            m_configuration["updater"]["configData"]["apiParameters"]["offset"] = nlohmann::json::object();
            m_configuration["updater"]["configData"]["apiParameters"]["offset"]["name"] = "offset";
            m_configuration["updater"]["configData"]["apiParameters"]["offset"]["step"] = 100;
            m_configuration["updater"]["configData"]["apiParameters"]["offset"]["start"] = 0;
        }

        if (!m_configuration.contains("exclusions"))
        {
            m_configuration["exclusions"] = nlohmann::json::object();
            m_configuration["exclusions"]["packages"] = nlohmann::json::array();
        }

        if (!m_configuration.contains("indexer"))
        {
            m_configuration["indexer"] = nlohmann::json::object();
            m_configuration["indexer"]["servers"] = nlohmann::json::array();
            m_configuration["indexer"]["servers"].push_back("http://localhost:9200");
            m_configuration["indexer"]["databasePath"] = "queue/indexer_vd";
        }
    }
    void call(nlohmann::json& data)
    {
        m_subject.setData(data);
    }

public:
    /**
     * @brief
     *
     * @param configuration
     */
    void initialize(const nlohmann::json& configuration)
    {
        m_configuration = configuration;

        setDefaultPolicy();

        // Subscription to policy change events.
        m_policyChangeSubscription = std::make_unique<RouterSubscriber>("policy", "vulnerability_scanner");
        m_policyChangeSubscription->subscribe(
            [this](const std::vector<char>& message)
            {
                m_configuration = nlohmann::json::parse(message);
                setDefaultPolicy();
                call(m_configuration);
            });
    }

    /**
     * @brief
     *
     * @param subscriber
     */
    void addSubscriber(std::shared_ptr<Observer<nlohmann::json&>> subscriber)
    {
        m_subject.attach(subscriber);
    }

    /**
     * @brief
     *
     * @param observerId
     */
    void removeSubscriber(const std::string& observerId)
    {
        m_subject.detach(observerId);
    }

    /**
     * @brief Get the Updater Configuration object
     *
     * @return nlohmann::json
     */
    nlohmann::json getUpdaterConfiguration() const
    {
        return m_configuration.at("updater");
    }

    /**
     * @brief Get the Exclusions object
     *
     * @return nlohmann::json
     */
    nlohmann::json getExclusions() const
    {
        return m_configuration.at("exclusions");
    }

    /**
     * @brief Get the Indexer Configuration object
     *
     * @return nlohmann::json
     */
    nlohmann::json getIndexerConfiguration() const
    {
        return m_configuration.at("indexer");
    }
};

#endif //_POLICY_MANAGER_HPP
